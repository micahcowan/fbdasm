# STACK: This document is a "note to self" that I use
# to keep track of what code I'm currently analyzing, and how I got
# there, so I can work my way back up to find the next bit of code
# to work on for some larger, overall routine.
#
# Unlike a 6502 CPU stack, all addresses given are the actual address
# (and not one less).

SEARCH STACK:
  
  I think GAME codes are stored at $D400 and on. In a data pointer table at $B00B
    Something interesting at $D000, too. a game background map, probably?
  Any other st* to NMICMD
  WaitForNmiSubcommand
  MarkWrappedLine
  PrintString
  QueueStringForOutput
  QueueCharForOutput
  QueueNullForOutput
  All routines in tbl_Commands and tbl_Functions
  Any remaining fns in CtrlCharInputHandlersTbl

BRANCH STACK:
  DefaultNmiHandler

  DirectModeLoop
  $8334 ExecuteDirectModeLine

  CmdFn_DATAorREM

  (ExecuteDirectModeLine)
    $8855 (StopIfStopKey)
    ->$885D (Stop)
        $8883 

  that bit below CmdFn_DATAorREM that is used to jump to next line link
  CmdFn_RUN
  ExecuteLine
    MaybePrintTrace
   ;$840B

NAME/explain:
  (ExecuteDirectModeLine stuff)
  LBB89 (table)
  L8855
   $55 ($B945)
   $66 "
.

  BUG: document that DATA token (small e) within comments is detected as DATA and handled accordingly. This is because it loops over SkipToken until it sees the DATA token, but SkipToken doesn't skip comments, just the REM or ' and each individual char after until it hits the token! (confirmed for both v2 and v3!)

  Document that NMI toggles between bg updates and sprite updates, when
   anims active, and how animation works
  Document how vars are stored in VARTAB, in DETAILS.md (and BUGS.md)
  Document keyboard mapping, and how fn keys work with ReadChar

Arrays: DIM A$(10)

  var name     max idx dim1
     +--\         |
     |   |        |
Var type |  n.dimens   max idx dim2
|    |   |     |  |     |
$83 $41 $00 | $00 $0A [$04]   <-- (first byte of first element...)
|    |   |     |  |     |
$02 $49 $00 | $01 $03 $03
