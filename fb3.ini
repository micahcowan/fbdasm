# SEARCH STACK:
#   
#   Any other st* to NMICMD
#   WaitForNmiSubcommand
#   MarkWrappedLine
#   PrintString
#   QueueStringForOutput
#   QueueCharForOutput
#   QueueNullForOutput
#
#   ReadKeyboard

# BRANCH STACK:
#   DefaultNmiHandler
#   ReadKeyboard
#   NMICMD_OutputTextToScreen
#   MarkWrappedLine
#   $8A40
#   *** looking for CR handling, to see if it involves MarkWrappedLine
#   $BD0D
#   $BD2F
#   *** Investigate what zpNMICMD=2 (idx 1) does (awaited in apparent CR handling at $BD43)
#   NMICMD_SomeKindOfCarriageReturnHandlerMaybe
#   $8A8E

RAM $32 zpPpuCtrlVal
RAM $33 zpPpuMaskVal
# Five bytes for holding output of HexStrFromWord.
# Entirely possible they're used for other temp storage, too.
RAM $3D zpHexStrTmp
RAM $3E zpHexStrTmp1
RAM $3F zpHexStrTmp2
RAM $40 zpHexStrTmp3
RAM $41 zpHexStrTmpTerm
# zCV was copied to this just prior to setting zpNMICMD=2 and awaiting NMI. Not sure what for.
# Other spots write other values to it.
RAM $47 zpSomeRowIndicator
# Current cursor column number
RAM $48 zpCH
# Current cursor row number
RAM $49 zpCV
# PPU address of tile under cursor
RAM $4A zpCursTileL
RAM $4B zpCursTileH
# The following selects between zpVScroll0 and zpvScroll1
# for RECEIVING updates ($F0 seems to select between them
# for SETTING the actual PPU scroll)
RAM $4F zpMaybeFreezesScroll4F
RAM $4F zpSomeKindaScrollingFlag4F
RAM $52 zpOutputStrL
RAM $53 zpOutputStrH
# Tells the NMI to call a designated handler,
# whose table idx is one less than the value in $63.
# Can be looped over until zero, to wait for NMI
# to finish handling it.
RAM $62 zpOutTxtCurPos
RAM $63 zpNMICMD
RAM $64 zpOutTxtStartPos
RAM $6B zpSavedCH
RAM $6C zpSavedCV
RAM $6F zp6F
RAM $70 zp70
RAM $71 zp71
RAM $AB zp_nmi_some_flag
# if $AC is non-zero, $AB is set to #$FF (triggering flag check on next frame)
RAM $AC zp_nmi_some_flag_1
# $E4, $E5: alternative scroll positions, selected by $F0.
# NMI handler will use whichever is selected to set the scroll position just before exit.
RAM $E4 zpVScroll0
RAM $E5 zpVScroll1
RAM $ED zpNmiTrampoline
RAM $EE zpNmiTrampoline_1
RAM $EF zpNmiTrampoline_2
# If the following is set, NMI uses $E5 to set vertical scroll position;
# if reset, it uses $E4 instead
RAM $F0 zpSomeKindaScrollingFlagF0

# $601 and $61B each point at the start of 24 bytes of data,
# one per visible screen row. They track whether a given
# line is wrapped or not (probably other things too?).
#
# Which one applies, is determined by
# the value of zpSomeKindaScrollingFlag ($4C): isRowWrappedArray0 ($601)
# if  $4C is exactly #$20; otherwise isRowWrappedArray1 ($61B).
RAM $601 isRowWrappedArray0
RAM $602 isRowWrappedArray0PlusOne
RAM $61B isRowWrappedArray1
RAM $61C isRowWrappedArray1PlusOne
RAM $634 KbdData
RAM $63B unkKbdFlag
# user directive messages (at least) get writen out to here:
RAM $700 outTxtBuf

# Hardware Ports

RAM $2000 PPUCTRL
RAM $2001 PPUMASK
RAM $2002 PPUSTATUS
RAM $2003 OAMADDR
RAM $2004 OAMDATA
RAM $2005 PPUSCROLL
RAM $2006 PPUADDR
RAM $2007 PPUDATA

RAM $4000 SQ1_VOL
RAM $4001 SQ1_SWEEP
RAM $4002 SQ1_LO
RAM $4003 SQ1_HI

RAM $4004 SQ2_VOL
RAM $4005 SQ2_SWEEP
RAM $4006 SQ2_LO
RAM $4007 SQ2_HI

RAM $4008 TRI_LINEAR
RAM $400A TRI_LO
RAM $400B TRI_HI

RAM $400C NOISE_VOL
RAM $400E NOISE_LO
RAM $400F NOISE_HI

RAM $4010 DMC_FREQ
RAM $4011 DMC_RAW
RAM $4012 DMC_START
RAM $4013 DMC_LEN

RAM $4014 OAM_DMA

RAM $4015 SND_CHN

RAM $4016 PAD1_KCTRL
RAM $4017 PAD2_KIN

# End Hardware Ports

CertainlyCode $0000 Start
CertainlyCode $00BA _Reset

CertainlyCode $01EC PpuGoToAX
Comment $01EC "Sets the current VRAM address from the A (high) and X (low) registers."

CertainlyCode $020D DirectTheUser
Comment $020D "Tell the user to do something"
Comment $020D "(turn backup switch on/off, power off, connect keyboard)"
CertainlyData $021C strON
CertainlyData $0220 strKEYBOARD_WO_SETSUZOKU
CertainlyData $022D strDENGEN_WO
CertainlyData $0234 strBACKUP_SWITCH_WO
CertainlyData $0242 strOFF_NI_SHITE_KUDASAI
CertainlyData $0246 strNI_SHITE_KUDASAI
CertainlyData $0248 strSHITE_KUDASAI

Comment $085D "Reset NMI sub-command"
CertainlyCode $093C QueueStringForOutput
Comment $093C "Copies the null-terminated string pointed at by zpOutputStr ($52) to outTxtBuf"
CertainlyCode $094B QueueNullForOutput
CertainlyCode $094D QueueCharForOutput
Comment $0957 "zpOutTxtCurPos <- #FF"
CertainlyCode $095A PrintString
Comment $095A "Copy a string to the output buffer, set zpNMICMD to NMICMD_OutputTextToScreen,"
Comment $095A "and wait for NMI handler to finish copying to the screen."
CertainlyCode $095D PrintOutBuf
Comment $095D "NUL-terminate the output buffer, and wait for NMI to print it."
Comment $0964 "NMICMD selector for NMICMD_OutputTextToScreen"
CertainlyCode $096A WaitForNmiSubcommand
Comment $096A "Set NMICMD and wait for NMI handler to finish processing it."
Comment $096C "wait for NMI to handle sub-command"
Comment $0988 "active NMI sub-command request?"
Comment $098A "yes: go handle sub-command"
Comment $0991 "Set up sub-command address, and jump"
CertainlyCode $0971 DefaultNmiHandler
CertainlyCode $09FA NMICMD_ClearToEndOfRow
Comment $09FA "Erases from cursor to end of current row."
CertainlyCode $0A0C NMICMD_OutputTextToScreen
CertainlyCode $0A87 NMICMD_SomeKindOfCarriageReturnHandlerMaybe
Comment $0A14 "Grab a char from out buf."
Comment $0A17 "If NUL, we've reached buffer end"
Comment $0A19 "Copy the character to the screen"
Comment $0A1C "Advance the cursor"
Comment $0A20 "Have we reached the end of the screen line?"
Comment $0A22 "yes -> handle wraparound to next line"
Comment $0A26 "Are we at the 15th column?"
Comment $0A28 "yes -> done printing for this frame"
Comment $0A2B "Loop back to output next character (always branch)"
Comment $0A2E "Done printing for this frame."
Comment $0A2E "Save our progress, and continue next frame."
Comment $0A7F "Indicate end of screen outputting, reset output buffer, cleanup, and exit."
Comment $0A7F "(This will terminate any loop awaiting this command's completion.)"
Comment $0A33 "We reached the end of the screen line: wrap around to next column"
Comment $0A50 "Output cursor has gone to a line below the screen."
Comment $0A50 "I'm guessing following code scrolls the screen?"

CertainlyCode $0ABA NmiTerminateSubCmdCleanupAndExit
CertainlyCode $0ABC NmiTransitionSubCmdCleanupAndExit
CertainlyCode $0ABE NmiCleanupAndExit
Comment $0ABE "Some kind of NMI cleanup must happen here -"
Comment $0ABE "Lots of NMICMD handlers jump to here when done."

CertainlyCode $11B8 HexFromNybble
Comment $11B8 "Converts a value from $0-$F to a hex digit in ASCII."
CertainlyCode $11C3 HexCharsFromByte
Comment $11C3 "Converts a byte into two hex digits in ASCII,"
Comment $11C3 "storing them at $3D + x."
CertainlyCode $11DA HexStrFromWord
Comment $11DA "Converts a word (at $28) into a null-terminated string of"
Comment $11DA "four hexadecimal digits in ASCII, stored at $3D thru $41."

CertainlyCode $3327 PrintHotStart
CertainlyCode $3237 PrintErrorAndStop
Comment $3237 "Prints the two-character error code
Comment $3237 "and (presumably) returns to direct mode."
Comment $3283 "Print '?' char"
CertainlyCode $32F7 PrintStartupText

CertainlyData $3338 strBASIC_HOT_START
CertainlyData $3349 strBYTES_FREE
CertainlyData $3349 strBYTES_FREE
CertainlyData $3355 strIN
CertainlyData $335A strBREAK
CertainlyData $3360 strERROR
CertainlyData $3367 strWRITING
CertainlyData $3370 strLOADING
CertainlyData $3379 strSKIP
Comment $337F "READ THESE AS LOW-THEN-HI (order of chars is reverse of what appears in words below)" 
Comment $337F "[NF]: NEXT without FOR"
Comment $3381 "[SN]: Syntax Error"
Comment $3383 "[RG]: RETURN without GOSUB"
Comment $3385 "[OD]: Out of Data"
Comment $3387 "[IL]: Illegal function call"
Comment $3389 "[OV]: Overflow"
Comment $338B "[OM]: Out of Memory"
Comment $338D "[UL]: Undefined Line number"
Comment $338F "[SO]: Subscript Out of range"
Comment $3391 "[DD]: Duplicate Definition"
Comment $3393 "[DZ]: Division by Zero"
Comment $3395 "[TM]: Type Mismatch"
Comment $3397 "[ST]: String Too long"
Comment $3399 "[FT]: Formula Too complex"
Comment $339B "[CC]: Cannot Continue"
Comment $339D "[UF]: Undefined Function"
Comment $339F "[MO]: Missing Operand"
Comment $33A1 "[TP]: Tape read error"
Comment $33A3 "[NR]: No Resume"
Comment $33A5 "[RE]: RESUME without ERROR"
Comment $33A7 "[NB]: No BG Data"
Comment $33A9 "[UP]: Unprintable Error"

CertainlyCode $342B WaitForVBlank
CertainlyData $344A strGAME_0
CertainlyData $3452 strGAME_1
CertainlyData $345A strGAME_2_1
CertainlyData $3464 strGAME_3
CertainlyData $346C strSPRITE
CertainlyData $3474 strLOAD
CertainlyData $347A strLIST
CertainlyData $3480 strRUN

CertainlyCode $34F4 SyncVarsForCurrentCursor
Comment $34F4 "Seems to sync various ZP vars and such,"
Comment $34F4 "based on the current cursor position."
Comment $34F4 "Notably, calculates the PPU address corresponding to the current cursor position."

CertainlyCode $352E PpuGoToCursor
Comment $352E "Sets the current VRAM address to the cursor's current tile position"

CertainlyCode $3539 NmiWriteTileSetVScrollAndEnableNMI
CertainlyCode $353C NmiSetVScrollAndEnableNMI
Comment $353C "Set the vertical scroll position from either zpVScroll0 or zpVScroll1,"
Comment $353C "depending on the value of zpSomeKindaScrollingFlag"
CertainlyCode $3559 AwaitVBlankAndZeroPpuMask
CertainlyCode $3562 AwaitVBlankAndUpdatePpuMask
CertainlyCode $35C7 ScrollScreenUpOneRow
Comment $35C7 "Scrolls the screen up by one row, leaving the cursor"
Comment $35C7 "on the first row of the (new) last row)."
Comment $35C7 ""
Comment $35C7 "...Listen. I know _what_ this function does, I haven't fully figured"
Comment $35C7 "the details of how it does it. I do, however, know it erases the top row"
Comment $35C7 "to blanks (so it can eventually be a future 'new row'), and then"
Comment $35C7 "adjusts the PPU scroll so that the former 2nd row is now the top row."
Comment $35C7 "(definitely way faster than copying a screenful of text!)"
Comment $35CF "Tell NMI handler to erase to end of row"
Comment $35CF "(Cursor is at home row, so erase entire top row)"
CertainlyCode $35D4 ScrollScreenOneRowNoErase
Comment $35D4 "Scrolls the screen WITHOUT clearing any lines."
Comment $35D4 "Fun thing to try:"
Comment $35D4 ""
Comment $35D4 "  10 CALL -18988:FOR P+1 TO 100:NEXT P:GOTO 10"
Comment $35D4 ""
Comment $35D4 "Then, optionally fill the screen with interesting things"
Comment $35D4 "and then RUN. It'll scroll the screen in a cycle!"

Comment $361A "always branches."
CertainlyCode $3645 MarkWrappedLine
Comment $3645 "Record that a given line was wrapped,"
Comment $3645 "and does not begin a new line of its own."
CertainlyCode $3656 SaveCursorPos
CertainlyCode $365F RestoreCursorPos
CertainlyCode $3710 CursorUp
CertainlyCode $3717 CursorDownPreserveCol
Comment $3717 "Exactly the same as CursorDown, _except_ in the case when"
Comment $3717 "the cursor moves past the end of the screen. In that case,"
Comment $3717 "CursorDown will leave cursor at the start of the new line;"
Comment $3717 "CursorDownPreserveCol will leave cursor at the original column."
CertainlyCode $3721 CursorLeft
Comment $3721 "already at leftmost column?"
Comment $3723 "yes -> check if we can go up a row"
Comment $3725 "no, so just back up a column."
Comment $3728 "already at topmost row?"
Comment $372A "yes -> nothing to do, exit"
Comment $372C "no, so go up a row and to the rightmost column"
CertainlyCode $3733 CursorRight
Comment $3735 "already in rightmost column?"
Comment $3737 "yes -> check if we can go to next row"
Comment $3739 "no, just go right a column"
Comment $3741 "are we on the last row?"
Comment $3743 "yes -> nothing to do, exit"
Comment $3745 "no, just drop down a row"
CertainlyCode $3748 CursorHome
CertainlyCode $374C CursorToRowStart
CertainlyCode $3751 CursorDown
Comment $3753 "increment row"
Comment $3754 "past last row?"
Comment $3756 "no -> store new row and exit"
Comment $3758 "yes"

CertainlyCode $3958 ReadKeyboard
Comment $3958 "Kbd reading routine."
Comment $3958 "See https://www.nesdev.org/wiki/Family_BASIC_Keyboard#Hardware_interface for details."
Comment $3958 ""
Comment $3958 "Write $05 to keyboard: reset row/col scanning"
Comment $3965 "Write $04: prep read for column 0 of a new row"
#
Comment $3971 ""
Comment $3971 "                    bit: 7       0"
Comment $3971 "Read col 0 scan results: ---x xxx-"
Comment $3971 ""
Comment $3971 "row 0: ]   ]   RET F8"
Comment $3971 "    1: ;   :   @   F7"
Comment $3971 "    2: K   L   O   F6"
Comment $3971 "    3: J   U   I   F5"
Comment $3971 "    4: H   G   Y   F4"
Comment $3971 "    5: D   R   T   F3"
Comment $3971 "    6: A   S   W   F2"
Comment $3971 "    7: CTR Q   ESC F1"
Comment $3971 "    8: LFT RGT UP  CLR"
Comment $3971 ""
#
Comment $3974 "Move to occupy the low nybble"
Comment $3977 "...and store in KbdData + <<ROW>>"
#
Comment $397A "Write $06: prep iead for column 1, same row"
#
Comment $3986 ""
Comment $3986 "                    bit: 7       0"
Comment $3986 "Read col 1 scan results: ---x xxx-"
Comment $3986 ""
Comment $3986 "row 0: STP \   RSH KANA"
Comment $3986 "    1: ^   -   /   _"
Comment $3986 "    2: 0   P   ,   ."
Comment $3986 "    3: 8   9   N   M"
Comment $3986 "    4: 6   7   V   B"
Comment $3986 "    5: 4   5   C   F"
Comment $3986 "    6: 3   E   Z   X"
Comment $3986 "    7: 2   1   GRP LSH"
Comment $3986 "    8: INS DEL sPC DWN"
Comment $3986 ""
#
Comment $3989 "Move to occupy the high nybble"
Comment $398E "Combine with low nybble (cols 0 and 1 now combined)
Comment $3991 "Invert the bits, so that 1 = pressed"
Comment $3993 "And then store them in reversed order"
Comment $399F "Loop around to handle the next keyboard row"

Comment $3D2F "Handle CR character (come-from $BD0D)
Comment $3D31 "Skip if we're on the topmost line"

CertainlyCode $3E0E SetPpuCtrl
Comment $3E0E "NOTE: Vblank NMI will be DISABLED, unless the high bit is set in zpPpuCtrlVal"
CertainlyCode $3E14 SetPpuCtrlAndEnableNMI

CertainlyData $4F7B strNS_HUDSON
Comment $4F7B "'NS-HUBASIC V3.0'"
CertainlyData $4F8C strCOPYRIGHT_MSG
Comment $4F8C "'Â© NINTENDO/SHARP/HUDSON'"

# Jump table definitions must appear AFTER any associated function names
DataTable $0250 $0251 2 7 tbl_DirectTheUserStrs
JumpTable $09A3 $09A4 2 15 NMICMD_JumpTable
DataTable $337F $3380 2 22 twoCharErrCodes
JumpTable $7FFA $7FFB 2 3 Vectors
