; This file maintains (1) labels for RAM locations, and (2) constants.
; It does *not* manage labels for any ROM locations (code or hard-coded data).
;
; It is automatically imported into SourceGen when you open fb3.nes.dis65.
;
; NAMING CONVENTIONS
;
; "zp" prefix for all labels for zero-page locations.
; "tbl_" prefix for data tables.
; "jtbl_" prefix for jump tables (tables of code addresses).
; "v" prefix: Local variable names, may override global names in a region
; Capitalized names for "global" code labels.
; lowerCase names for:
;  - all data (ROM or RAM).
;  - code labels that aren't properly full routiness in their own right.
; CamelCase in general. Acronyms treated like any other word (except
;  in some prefixes).
; Some zp vars, like TXTTAB, VARTAB, TXTPTR, get all-caps. They are
;  named bc their function is similar to same-named vars in common
;  Microsoft BASIC implementations. Some related names that did not exist
;  in BASICs I'm familiar with also got all-caps.
; Primary references to keywords are also ALL-CAPS.
; Trampoline routines are labeled with abbreviated destination label, +
;  underscore and trampoline's address. Same for branched-to RTS from outside.
;
; I'm not super-consistent about naming of constants. Kinda by vibe.

; PPU addrs

PPU_PALETTE_RAM = $3F00

; Zero-page vars
zp02            @  $02
zpFRETOP        @  $03    2 ; Pointer to just past the end of free space.
zpTXTTAB        @  $05    2 ; Pointer to the start of the BASIC program code. Always set to $6006.
zpTXTEND        @  $07    2 ; Ponter to just past the program end (zpTXTEND - zpTXTTAB = prog len)
zpTXTPTR        @  $09    2 ; Points at the next char of BASIC program to be processed.
zpRunLineNum    @  $0B    2 ; When BASIC running, it's the current line number, or #$FFFF if it's direct from the command prompt. When inserting or deleting lines, this var instead points at the next line of BASIC program after the one to be ins/del
zpRunTxtNxtLnk  @  $0D    2 ; When BASIC running, it's a pointer at the next line (starting at its "offset" byte)
zpInsLineNum    @  $0F    2 ; Line number to give newly-inserted line
zpContRunLineNum @ $11    2 ; Saved zpRunLineNum for CONT restore
zpContRunTxtNxtL @ $13    2 ; Saved zpRunTxtNxtLnk for CONT restore
zpContTxtThisCmd @ $15    2 ; Saved zpTxtThisCmd for CONT restore
zpSavedStack    @  $17      ; Saved SP
zpModifierKeyDn @  $18      ; Non-zero when modifier key is pressed
zpMisc          @  $19    4 ; Used for a wide variety of things, mainly temporary pointers
zpVARTAB        @  $1D    2 ; Start of variable storage
zpVAREND        @  $1F    2 ; Just past end of variable storage
zpGpStrIdx      @  $21      ; Index for temp string storage in genPurposeBuf
zp22            @  $22      ; Written to once, in NEW/_Reset. Never used.
zpStoppedFlag   @  $24      ; Non-zero if STOPped; zero otherwise.
zpPokeAddr      @  $25    2 ; stores addr to POKE to
zpArgTyp        @  $27    ; Designates the type of data in zpWAccum.
zpWAccum        @  $28    4 ; Like a 16-bit Accumulator. Forms both the first operand, and the result, of various 16-bit integer operations. Or: byte Len followed by word ptr, for strings.
zpWParam        @  $2C    3 ; Like a 16-bit Data register. forms the second operand of various binary operators
zpExprStkIdx    @  $30    ; Current position in exprParseStk
zpPpuCtrlVal    @  $32
zpPpuMaskVal    @  $33
zpMulScratch    @  $34    8 ; Used for multiplication scratch space. Only the first four are ever actually used!
zpTmp3C         @  $3C
zpNumStrTmp     @  $3D    5 ; Holds str output from HexStrFromWord and DecStrFromWOrd
zpFindLNum      @  $44    2
zpTmp46         @  $46    1 ; various miscellaneous uses
zpLineStartRow  @  $47      ; the screen row at which current typed line starts (only set AFTER typing is finished)
zpCH            @  $48      ; Current cursor column number
zpCV            @  $49      ; Current cursor row number
zpCursTileAddr  @  $4A    2 ; PPU address of tile under cursor
zpInsertMode    @  $4C      ; Zero = overwrite, non-zero = insert
zpTokenizePtr   @  $4D    2
zpPpuScreenBasePage     @  $4F ; The VRAM page used for the current screen we're UPDATING (may not be the one displayed)!
zpKanaHeld      @  $50      ; Non-zero (#$FF) if KANA key is still being held down from when it was first detected. Used to prevent rapid toggling.
zpListOrDelete  @  $51      ; Non-zero (#$FF) if we're in DELETE; zero if we're in LIST
zpOutputStr     @  $52    2 ; Pointer to null-term'd string to be queued for output
zpTokTblScn     @  $54    2 ; Used to scan thru tbl_KeywordTokens
zpRandom        @  $56    2 ; Used for RAND
zpTxtThisCmd    @  $58    2 ; The start of the currently-running command. Restored to zpTXTPTR on RESUME or CONT.
zpNewLineOffset @  $5A      ; Offset to next line for not-yet-placed, tokenized line
zpTxtLink       @  $5B    2 ; Points to the start of the current program line (including the 3-byte preamble)
zpNmiAnimActCtr @  $5D      ; Counts how many actors are not currently animated, and turns off zpNmiAnimate if it reaches zero
zpUnusedStopFlg @  $5E      ; Causes STOP to be returned by ReadChar when set, but is never actually set by anything AFAICT
zpSavedRts      @  $5F    2 ; FOR, GOSUB, other cmds pull return from stack, save here
zpCursorChar    @  $61      ; The character code of the current cursor
zpOutTxtCurPos  @  $62
zpNMICMD        @  $63      ; Which command the NMI handler should execute. 1 + the command's index in jtbl_NMICMD.
zpOutTxtStartPos @ $64
zpPaletBgOrSpr  @  $65      ; zero when we're setting bg palette colors, non-zero when setting sprite palette
zpRkimMidMacro  @  $66      ; Non-zero (#$FF) if ReaKeyInsMacros ($B945) should insert next char from a fkey definition (next char is at $480 + ($67)) rather than read from keyboard.
zpFnKeyDfnOff   @  $67      ; Offset from $480 into cur fn key definition string
zpFnKeyHeld     @  $68      ; Non-zero ($FF) if a function key is still being held down from when it was first detected. Used to prevent continuous handling while pressed.
zpFnKeyCode     @  $6A      ; Pressed function key (#$F0-$F7, for keys F1-F8).
zpSavedCH       @  $6B
zpSavedCV       @  $6C
zpKeyWhichKey   @  $6D      ; Within ReadKeyboard, which key of the row in $6E was found pressed. Outside ReadKeyboard, when the mapped char code is > #$F0, its value will often be stored here while further code determines if a function key was pressed.
zpKeyWhichRow   @  $6E      ; which key matrix row/byte of key has a non-modifier key down
zpCtrlKeyDn     @  $6F      ; Non-zero (#$FF) when control key is pressed
zpShiftKeyDn    @  $70      ; Non-zero (#$FF) when (either) shift key is pressed
zpGrphKeyDn     @  $71      ; Non-zero (#$FF) when GRPH key is pressed
zpKanaFlag      @  $72      ; Non-zero (#$FF) when kana mode is active
zpCharUnderCurs @  $73      ; The character currently under cursor
zpCursFlashCtr  @  $74      ; Delay count-down for when cursor should show/hide
zpHeldKeyChar   @  $75      ; Holds the char value of a key being held down
zpLineBufIdx    @  $76      ; Current write position into lineBuffer ($500)
zpKyRptLongCtr  @  $77      ; Key-repeat: delay count-down to first key repeat on long-press
zpKyNotRpt      @  $78      ; Key-repeat: #$01 = waiting on first key repeat, #$00 = on subsequent repeats
zpKyRptShtCtr   @  $79      ; Key-repeat: delay count-down for repeating key past the first, longer pause.
zpKeyRepeating  @  $7B      ; Key-repeat: #$FF = key is actively repeating, #$00 = key not repeating
zp7C            @  $7C
zp7D            @  $7D
zp7E            @  $7E
zpForLimitVal   @  $80    2 ; the limiting value that will cause an exit from FOR statement
zpForStepVal    @  $82    2 ; the step value by which to increment the index variable for a FOR statement
zpForNxtLnLnk   @  $84    2 ; link to the line of BASIC after the current FOR loop
zpLNumStart     @  $86    2 ; Starting line number of a line-number range
zpLNumEnd       @  $88    2 ; Ending line number of a line-number range
zpVarName       @  $8A    2 ; Two-letter variable name
zpVarData       @  $8C    2 ; pointer to selected variable data (deep, if var is array)
zpVARPTR        @  $8E    2 ; pointer to start of selected variable
zpVarType       @  $90      ; Often indicates type of a found variable. Other misc uses also occur.
zpCasCksum      @  $91    2 ; Checksum for cassette data, also used for misc counting
zpTraceOnFlag   @  $97      ; Flag for whether to trace line numbers (TRON)
zpSavedTxtChar  @  $98
zpToken         @  $99
zpSavedTXTPTR   @  $9A    2 ; Saved val of zpTXTPTR
zpPaletteNum    @  $9C
zpLoadQFlag     @  $9F      ; True if we're in "LOAD?" rather than "LOAD"
zpNxtAutoLNum   @  $A0    2 ; Next line number to use (for AUTO)
zpAutoLNumIncr  @  $A2    2 ; How much to auto-increment each line number (from AUTO)
zpActorNum      @  $A4      ; Current work actor
zpDefMovIdx     @  $A5      ; cur actor # times 8, for indexing defMovS* vars
zpNmiDefMovIdx  @  $A6      ; (NMI) cur actor # times 8, for indexing defMovS* vars
zpNmiCurMTbl    @  $A7    2 ; (NMI) address of the mbtl for current actor
zpNmiActorNum   @  $A9      ; Current work actor, used by NMI
zpNmiAnimNxtFr  @  $AB      ; While zpNmiAnimate is non-zero, this flag toggles every frame. Z = Handle NMI subcmds; NZ = Handle MOVEs
zpNmiAnimate    @  $AC      ; This flag indicates that animated characters are active (via MOVE)
zpCasBufPtr     @  $AD    2 ; Start of data to send to cassette
zpCasEndPtr     @  $AF    2 ; End of data to send to cassette
zpVerfFlag      @  $B1      ; If set, VERIFIES rather than LOADs a program. Used for "LOAD?".
zpNextDataPtr   @  $B2    2 ; Pointer to first content byte of line to start search for next DATA to READ
zpNextDataIdx   @  $B4      ; Char index into line at zpNextDataPtr to start from
zpErrCode       @  $B5
zpUnusedErrVar  @  $B6      ; This var is only ever used in one place, where it's set to zero.
zpErrLineNum    @  $B7    2 ; Line number where an error happened
zpTempo         @  $B9    3 ; tempo setting for each of the three voices
zpVolume        @  $BC    3 ; volume level for each of the three voices
zpOctave        @  $BF    3 ; octave # for each of the three voices
zpSharpVal      @  $C2      ; whether to sharp next note. 2 = yes, 0 = no
zpNoteLen       @  $C3    3 ; note length for each voice
zpPlayVoxIdx    @  $C6    3 ; start index into genPurposeBuf for each voice
zpPlayStatus    @  $C9      ; <0: error. >0: active voices mask. ==0: done playing.
zpCurVoice      @  $CA      ; the voice the NMI music player is working on
zpNoteRealLen   @  $CB    3 ; tempo-adjusted note length for each of the three voices
zpCurVoxMask    @  $CE      ; SND_CHN mask for the current sound channel
zpEnvelope      @  $CF    3 ; envelope setting for each voice. ENV_UNUSED (#$30) when no envelope, zero when using volume as envelope
zpDuty          @  $D2    3 ; cycle duty for each voice.
zpNmiCurFrCnts  @  $D5    2 ; (NMI) Pointer to vector being used for current actor's anim frame counts, for each facing
zpNmiNumFrames  @  $D7      ; (NMI) Holds the number of anim frames for the actor's cur facing (in high nybble)
zpNmiCurSprSht  @  $D9    2 ; (NMI) Pointer to sheet of sprites for each facing
zpNmiSprTileMp  @  $DB    2 ; (NMI) Pointer to the 2x2 tilemap to display for current actor
zpNmiSprShtOff  @  $DD      ; (NMI) Value to add to each tile ID in a sprite sheet, to get IDs for this actor.
zpKanaCursChr   @  $E0      ; character/tile ID to use for cursor when kana active
zpNonKCursChr   @  $E1      ; character/tile ID to use for cursor when kana NOT active
zpAutoEnabled   @  $E2      ; non-zero (=10) when AUTO active; zero means inactive
zpKeyClickFlg   @  $E3      ; non-zero = key clicks on
zpVScroll0      @  $E4      ; Vertical scroll used when SCREEN 0 is displayed
zpVScroll1      @  $E5      ; Vertical scroll used when SCREEN 1 is displayed; updated when $F0 is set
zpErrHandStat   @  $E7      ; #$00 - no error, #$01 - error, not resumable, #$02 - error, resumable
zpErrHandLNum   @  $E8    2 ; line number to jump to when error occurs
zpHaveFNameArg  @  $EA      ; true when LOAD was given a filename arg
zpNmiTrampoline @  $ED    3 ; Contains a JMP instruction to the real NMI handler. It's set to: JMP $8971
zpCurScreenNum  @  $F0      ; the _displayed_ SCREEN (0 or 1). Kept in sync with zpPpuScreenBasePage
zpGameNum       @  $F3      ; Game number (GAME cmd)
zpRsmTxtThisCmd @  $F6    2 ; Saved zpTxtThisCmd for RESUME restore
zpRsmRunTxtNxtL @  $F8    2 ; Saved zpRunTxtNxtLnk for RESUME restore
zpRsmRunLineNum @  $FA    2 ; Saved zpRunLineNum for RESUME restore

oamBuffer       @  $200   256 ; Region for PPU sprite data DMA
oamSprYPos      @  $200
oamSprTileId    @  $201
oamSprAttr      @  $202
oamSprXPos      @  $203
tokenizeBuffer  @  $300   256
exprParseStk    @  $400   128; expression evaluation stack
;strResultLen    @  $400     ; Length of the string result
;strResultLen    @  $400     ; Length of the string result
;strResultPtr    @  $401   2 ; String result after evaluating formula (arg)
fnKey1_DfnBuf   @  $480   16; Current definitions of the FN-key shortcuts, each 16 chars
fnKey2_DfnBuf   @  $490   16
fnKey3_DfnBuf   @  $4A0   16
fnKey4_DfnBuf   @  $4B0   16
fnKey5_DfnBuf   @  $4C0   16
fnKey6_DfnBuf   @  $4D0   16
fnKey7_DfnBuf   @  $4E0   16
fnKey8_DfnBuf   @  $4F0   16
lineBuffer      @  $500   256; NMICMD_BufferCurLine copies the full current, potentially multi-row line to here
bgtCurRowTileIds@  $510   16 ; tile IDs for the currently-selected row of tiles in SELECT mode, separated by spaces
;fileName       @  $580   17; SAVE and LOAD put their string arg here.
isRowWrappedArray0  @  $601 24 ; Marks which visible screen rows are wrapped from previous line, if SCREEN 0.
isRowWrappedArray1  @  $61B 24 ; Marks which visible screen rows are wrapped from previous line, if SCREEN 1.
kbdDataAry      @  $634   9  ; Key down bitmap. See loc $B9A1 for content details
sprTwoByTwoFlags @ $63D   8  ; 1x1-tile (#$00) vs 2x2 (#$01), for each actor.
sprAttrFlags    @  $645   8  ; Sprite tile attributes for the 8 actors. See SpAtt_* for flag values.
sprTileMaps     @  $680   32 ; Sprite tile maps for the 8 actors (4 tiles/actor)
defMovSFacing   @  $6C0      ; Actor MOVE direction (swapped with type, relative to DEF MOVE arg order)
defMovSActorFrm @  $6C1      ; Low nybble: MOVE character type (Mario, Lady, Star Killer, etc)A; high nybble: which frame of animation frame we're on
defMovSSpdCtr   @  $6C2      ; Actor MOVE speed counter
defMovSMotionCtr @ $6C3      ; Actor MOVE total movement remaining
defMovSSpeed    @  $6C4      ; Actor MOVE total movement remaining
defMovSMotion   @  $6C5      ; Actor MOVE total movement remaining
defMovSPosX     @  $6C6      ; Actor MOVE, current X position
defMovSPosY     @  $6C7      ; Actor MOVE, current Y position
genPurposeBuf   @  $700   256; user directive messages (at least) get writen out to here

bgGotFlag       @  $6004  ; non-zero if bg data is saved at $6C00
bgGetVScroll    @  $6005  ; saved vscroll for saved screen data
basicProgram    @  $6006  ; The start of the BASIC program in memory
bgGetRam        @  $6C00 1024; region to save bg data with BGGET
memoryTop       @  $6FFF  ; What FRETOP is set to by default

COLS = 28
ROWS = 24

STRLEN_MAX = 32

NUM_ACTORS = 8  ; number of animated characters ("actors") in Family BASIC

NUM_PALETTES = 4; number of palettes in a palette set

TileId_emptyBox = $B0

FOR_STK_MARKER   = $00FD  ; special CPU stack marker for FOR-loop data
GOSUB_STK_MARKER = $00FF  ; special CPU stack marker for RETURN data

PLAY_INDEX_V0 = 0
PLAY_INDEX_V1 = 33
PLAY_INDEX_V2 = 66

; mask values for SND_CHN ($4015)
CHAN_MASK_TRI  = 4
CHAN_MASK_SQR1 = 2
CHAN_MASK_SQR0 = 1

ENV_USED   = $00    ; value used with zpEnvelope to indicate envelope in use for given voice
ENV_UNUSED = $30    ; value used with zpEnvelope to indicate envelope not used for given voice

SHARP_UNUSED = $00
SHARP_USED   = $02

NOTE_VAL_OCTAVE = 24

NC_NoCmd                    = 0
NC_FlushOutp                = 1
NC_BufferCurLine            = 2
NC_CopyCharsLeft            = 3
NC_ClearToEndOfRow          = 4
NC_GetCharUnderCursor       = 5
NC_SetBgPalette             = 6
NC_SetSprPalette            = 7
NC_ShowCursor               = 8
NC_RestoreCharAtCursor      = 9
NC_PlayMusic                = 10
NC_PpuMaskUpdate            = 11
NC_PpuMaskClear             = 12
NC_InsertChar               = 13
NC_CopyRowDown              = 14
NC_CopyRowDown_pr1          = 15

VRAM_screen0    =  $2000
VRAM_screen1    =  $2400

SPR_NullTile    =  $EF

; Sprite tile attributes flags, $645.64C
SpAtt_VFLIP        = $80       ; bit 7. RESET: flip sprite vertically(?)
SpAtt_HFLIP        = $40       ; bit 6. RESET: flip sprite horizontally(?)
SpAtt_BEHIND       = $20       ; bit 5. SET: behind bg; RESET: in front
SpAtt_ANIMATE      = $10       ; bit 4. SET: actor is animated
SpAtt_DEFMOVE      = $08       ; bit 3. SET: actor has a MOVE defined

TYP_INT         =  $02      ; For zpArgTyp. Integer word.
TYP_STR         =  $03      ; For zpArgTyp. String.
TYP_ARRAY_FLAG  =  $80      ; Flag bit indicating array type.

CAS_HDR_PROG    = $02       ; Identity byte in header for prog saves to cassette tape.
CAS_HDR_SCREEN  = $03       ; Identity byte in header for screen saves to cassette tape.

; DirectTheUser message index values
DTU__ON                     = 0
DTU__KEYBOARD_WO_SETSUZOKU  = 1
DTU__DENGEN_WO              = 2
DTU__BACKUP_SWITCH_WO       = 3
DTU__OFF_NI_SHITE_KUDASAI   = 4
DTU__NI_SHITE_KUDASAI       = 5
DTU__SHITE_KUDASAI          = 6

; Flags for zpErrHandStat
EH_NO_HANDLER       = $00
EH_HANDLER_DEFINED  = $01
EH_IN_HANDLER       = $02

err_NF          = $00       ; "NF" - NEXT without FOR
err_SN          = $01       ; "SN" - Syntax Error
err_RG          = $02       ; "RG" - RETURN without GOSUB
err_OD          = $03       ; "OD" - Out of Data
err_IL          = $04       ; "IL" - Illegal value
err_OV          = $05       ; "OV" - Overflow
err_OM          = $06       ; "OM" - Out of Memory
err_UL          = $07       ; "UL" - Undefined Line number
err_SO          = $08       ; "SO" - Subscript Out of range
err_DD          = $09       ; "DD" - Duplicate Definition
err_DZ          = $0A       ; "DZ" - Division by Zero
err_TM          = $0B       ; "TM" - Type Mismatch
err_ST          = $0C       ; "ST" - String Too long
err_FT          = $0D       ; "FT" - Formula Too complex
err_CC          = $0E       ; "CC" - Cannot Continue
err_UF          = $0F       ; "UF" - Undefined Function
err_MO          = $10       ; "MO" - Missing Operand
err_TP          = $11       ; "TP" - Tape read error
err_NR          = $12       ; "NR" - No Resume
err_RE          = $13       ; "RE" - RESUME without ERROR
err_NB          = $14       ; "NB" - No BG Data
err_UP          = $15       ; "UP" - Unprintable Error

tok_LNUM_AFTER  = $0B       ; indicates a line number (word) follows this byte
tok_LLINK_AFTER = $0C       ; indicates a direct link to a line follows - only used during a RENUM
tok_HEX_AFTER   = $11       ; indicates a number (word) follows this byte, originally hexadecimal
tok_NUM_AFTER   = $12       ; indicates a number (word) follows this byte, originally decimal

TOKEN_START     = $80
tok_GOTO        = $80
tok_GOSUB       = $81
tok_RUN         = $82
tok_RETURN      = $83
tok_RESTORE     = $84
tok_THEN        = $85
tok_LIST        = $86
tok_SYSTEM      = $87
tok_TO          = $88
tok_STEP        = $89
tok_SPRITE      = $8A
tok_PRINT       = $8B
tok_FOR         = $8C
tok_NEXT        = $8D
tok_PAUSE       = $8E
tok_INPUT       = $8F
tok_LINPUT      = $90
tok_DATA        = $91
tok_IF          = $92
tok_READ        = $93
tok_DIM         = $94
tok_REM         = $95
tok_STOP        = $96
tok_CONT        = $97
tok_CLS         = $98
tok_CLEAR       = $99
tok_ON          = $9A
tok_OFF         = $9B
tok_CUT         = $9C
tok_NEW         = $9D
tok_POKE        = $9E
tok_CGSET       = $9F
tok_VIEW        = $A0
tok_MOVE        = $A1
tok_END         = $A2
tok_PLAY        = $A3
tok_BEEP        = $A4
tok_LOAD        = $A5
tok_SAVE        = $A6
tok_POSITION    = $A7
tok_KEY         = $A8
tok_COLOR       = $A9
tok_DEF         = $AA
tok_CGEN        = $AB
tok_SWAP        = $AC
tok_CALL        = $AD
tok_LOCATE      = $AE
tok_PALET       = $AF
tok_ERA         = $B0
tok_TR          = $B1
tok_FIND        = $B2
tok_GAME        = $B3
tok_BGTOOL      = $B4
tok_AUTO        = $B5
tok_DELETE      = $B6
tok_RENUM       = $B7
tok_FILTER      = $B8
tok_CLICK       = $B9
tok_SCREEN      = $BA
tok_BACKUP      = $BB
tok_ERROR       = $BC
tok_RESUME      = $BD
tok_BGPUT       = $BE
tok_BGGET       = $BF
tok_CAN         = $C0
tok_OP_XOR      = $EF
tok_OP_OR      = $F0
tok_OP_AND      = $F1
tok_OP_NOT      = $F2
tok_OP_NE       = $F3
tok_OP_GE       = $F4
tok_OP_LE       = $F5
tok_OP_EQ       = $F6
tok_OP_GT       = $F7
tok_OP_LT       = $F8
tok_OP_PLUS     = $F9
tok_OP_MINUS    = $FA
tok_OP_MOD      = $FB
tok_OP_DIV      = $FC
tok_OP_MUL      = $FD
tok_ABS         = $CA
tok_ASC         = $CB
tok_STR_STR     = $CC
tok_FRE         = $CD
tok_LEN         = $CE
tok_PEEK        = $CF
tok_RND         = $D0
tok_SGN         = $D1
tok_SPC         = $D2
tok_TAB         = $D3
tok_MID_STR     = $D4
tok_STICK       = $D5
tok_STRIG       = $D6
tok_XPOS        = $D7
tok_YPOS        = $D8
tok_VAL         = $D9
tok_POS         = $DA
tok_CSRLIN      = $DB
tok_CHR_STR     = $DC
tok_HEX_STR     = $DD
tok_INKEY_STR   = $DE
tok_RIGHT_STR   = $DF
tok_LEFT_STR    = $E0
tok_SCR_STR     = $E1
tok_INSTR       = $E2
tok_CRASH       = $E3
tok_ERR         = $E4
tok_ERL         = $E5
tok_VCT         = $E6
