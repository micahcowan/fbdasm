; This file maintains (1) labels for RAM locations, and (2) constants.
; It does *not* manage labels for any ROM locations (code or hard-coded data).
;
; It is automatically imported into SourceGen when you open fb3.nes.dis65.
;
; NAMING CONVENTIONS
;
; "zp" prefix for all labels for zero-page locations.
; "tbl_" prefix for data tables.
; "jtbl_" prefix for jump tables (tables of code addresses).
; Capitalized names for "global" code labels.
; lowerCase names for:
;  - all data (ROM or RAM).
;  - code labels that aren't properly full routiness in their own right.
; CamelCase in general. Acronyms treated like any other word (except
;  in some prefixes).
; Some vars, like TXTTAB, VARTAB, TXTPTR, get all-caps. They are
;  named bc their function is similar to same-named vars in common
;  Microsoft BASIC implementations.
; References to keywords are also ALL-CAPS.
; I'm not super-consistent about naming of constants. Kinda by vibe.

zpTXTTAB    @   $05     2       ; Pointer to the start of the BASIC program code. Always set to $6006.
zpVARTAB    @   $07     2       ; Ponter to variables start/program end
zpTXTPTR    @   $09     2       ; Points at the next char of BASIC program to be processed.
zpTxtNextLink   @       $0B     2   ; Points at the next line of BASIC program after current
zpMisc          @       $19     4   ; Used for a wide variety of things, mainly temporary pointers
zpArgTyp        @       $27         ; Designates the type of data in zpWAccum.
zpWAccum        @       $28     3   ; Like a 16-bit Accumulator. Forms both the first operand, and the result, of various 16-bit integer operations. Or: byte Len followed by word ptr, for strings.
zpWParam        @       $2C     3   ; Like a 16-bit Data register. forms the second operand of various binary operators

zpPpuCtrlVal    @       $32
zpPpuMaskVal    @       $33

zpMulScratch  @       $34     8   ; Used for multiplication scratch space. Only the first four are ever actually used!

zpHexStrTmp     @       $3D     5   ; Holds str output from HexStrFromWord
zpLineNum       @       $44     2
zpSomeRowIndicator      @       $47 ; zCV was copied to this just prior to setting zpNMICMD=2 and awaiting NMI. Other uses elsewhere.
zpCH    @       $48 ; Current cursor column number
zpCV    @       $49 ; Current cursor row number

zpCursTileAddr  @       $4A     2 ; PPU address of tile under cursor
zpInsertMode    @       $4c       ; Zero = overwrite, non-zero = insert
zpTokenizeOut   @       $4D     2
zpPpuScreenBasePage     @       $4F ; The VRAM page used for the current screen we're UPDATING (may not be the one displayed)!
zpOutputStr     @       $52     2 ; Pointer to null-term'd string to copy to outTxtBuf
zpTokTblScn     @       $54     2 ; Used to scan thru tbl_KeywordTokens
zpNewLineOffset @       $5a       ; Offset to next line for not-yet-placed, tokenized line
zpTxtLink       @       $5b     2 ; Points to the start of the current program line (including the 3-byte preamble)
zpSavedRts      @       $5f     2 ; FOR, GOSUB, other cmds pull return from stack, save here
zpOutTxtCurPos  @       $62
zpNMICMD        @       $63 ; Which command the NMI handler should execute. 1 + the command's index in jtbl_NMICMD.

zpOutTxtStartPos        @       $64
zpSavedCH       @       $6B
zpSavedCV       @       $6C
zpLineBufIdx    @       $76 ; Current write position into lineBuffer ($500)
zpCasCksum      @       $91     2   ; Checksum for cassette data, also used for misc counting
zpSavedTxtChar  @       $98
zpToken         @       $99
zpSavedTXTPTR   @       $9a     2   ; Saved val of zpTXTPTR
zpNxtAutoLNum   @       $a0     2   ; Next line number to use (for AUTO)
zAutoLNumIncr   @       $a2     2   ; How much to auto-increment each line number (from AUTO)

zpNmiSomeFlag   @       $AB
zpNmiSomeFlag1  @       $AC ; if $AC is non-zero, $AB is set to #$FF (triggering flag check on next frame)

zpCasBufPtr     @       $AD     2   ; Start of data to send to cassette
zpCasEndPtr     @       $AF     2   ; End of data to send to cassette

zpErrCode       @       $B5
zpVScroll0      @       $E4 ; Vertical scroll used when SCREEN 0 is displayed
zpVScroll1      @       $E5 ; Vertical scroll used when SCREEN 1 is displayed; updated when $F0 is set
zpNmiTrampoline @       $ED 3 ; Contains a JMP instruction to the real NMI handler. It's set to: JMP $8971
zpCurScreenNum  @       $F0 ; the _displayed_ SCREEN (0 or 1). Kept in sync with zpPpuScreenBasePage
zpGameNum       @       $F3 ; Game number (GAME cmd)

tokenizeBuffer  @       $300    256
strResultLen    @       $400        ; Length of the string result
strResultPtr    @       $401    2   ; String result after evaluating formula (arg)
fnKey1_DfnBuf   @       $480    16  ; Current definitions of the FN-key shortcuts, each 16 chars
fnKey2_DfnBuf   @       $490    16
fnKey3_DfnBuf   @       $4A0    16
fnKey4_DfnBuf   @       $4B0    16
fnKey5_DfnBuf   @       $4C0    16
fnKey6_DfnBuf   @       $4D0    16
fnKey7_DfnBuf   @       $4E0    16
fnKey8_DfnBuf   @       $4F0    16

lineBuffer      @       $500    256 ; NMICMD_BufferCurLine copies the full current, potentially multi-row line to here
progName        @       $580    17  ; SAVE and LOAD put their string arg here.

isRowWrappedArray0      @       $601 24 ; Marks which visible screen rows are wrapped from previous line, if SCREEN 0.
isRowWrappedArray1      @       $61B 24 ; Marks which visible screen rows are wrapped from previous line, if SCREEN 1.

kbdDataAry @       $634    9
unkKbdFlag      @       $63B
outTxtBuf       @       $700    256 ; user directive messages (at least) get writen out to here

basicProgram    @       $6006 ; The start of the BASIC program in memory

NC_NoCmd            = 0
NC_FlushOutp        = 1
NC_BufferCurLine    = 2
NC_ClearToEndOfRow  = 4

VRAM_screen0    = $2000
VRAM_screen1    = $2400

TYP_INT = $02   ; For zpArgTyp. Integer word.
TYP_STR = $03   ; For zpArgTyp. String.

tok_LNUM_AFTER  = $0b   ; indicates a line number (word) follows this byte
tok_HEX_AFTER   = $11   ; indicates a number (word) follows this byte, originally hexadecimal
tok_NUM_AFTER   = $12   ; indicates a number (word) follows this byte, originally decimal

tok_GOTO    = $80
tok_GOSUB   = $81
tok_RUN = $82
tok_RETURN  = $83
tok_RESTORE = $84
tok_THEN    = $85
tok_LIST    = $86
tok_SYSTEM  = $87
tok_TO  = $88
tok_STEP    = $89
tok_SPRITE  = $8a
tok_PRINT   = $8b
tok_FOR = $8c
tok_NEXT    = $8d
tok_PAUSE   = $8e
tok_INPUT   = $8f
tok_LINPUT  = $90
tok_DATA    = $91
tok_IF  = $92
tok_READ    = $93
tok_DIM = $94
tok_REM = $95
tok_STOP    = $96
tok_CONT    = $97
tok_CLS = $98
tok_CLEAR   = $99
tok_ON  = $9a
tok_OFF = $9b
tok_CUT = $9c
tok_NEW = $9d
tok_POKE    = $9e
tok_CGSET   = $9f
tok_VIEW    = $a0
tok_MOVE    = $a1
tok_END = $a2
tok_PLAY    = $a3
tok_BEEP    = $a4
tok_LOAD    = $a5
tok_SAVE    = $a6
tok_POSITION    = $a7
tok_KEY = $a8
tok_COLOR   = $a9
tok_DEF = $aa
tok_CGEN    = $ab
tok_SWAP    = $ac
tok_CALL    = $ad
tok_LOCATE  = $ae
tok_PALET   = $af
tok_ERA = $b0
tok_TR  = $b1
tok_FIND    = $b2
tok_GAME    = $b3
tok_BGTOOL  = $b4
tok_AUTO    = $b5
tok_DELETE  = $b6
tok_RENUM   = $b7
tok_FILTER  = $b8
tok_CLICK   = $b9
tok_SCREEN  = $ba
tok_BACKUP  = $bb
tok_ERROR   = $bc
tok_RESUME  = $bd
tok_BGPUT   = $be
tok_BGGET   = $bf
tok_CAN = $c0
tok_XOR = $ef
tok_OR  = $f0
tok_AND = $f1
tok_NOT = $f2
tok_OP_NE   = $f3
tok_OP_GE   = $f4
tok_OP_LE   = $f5
tok_OP_EQ   = $f6
tok_OP_GT   = $f7
tok_OP_LT   = $f8
tok_OP_PLUS = $f9
tok_OP_MINUS    = $fa
tok_MOD = $fb
tok_OP_DIV  = $fc
tok_OP_MUL  = $fd
tok_ABS = $ca
tok_ASC = $cb
tok_STR_STR    = $cc
tok_FRE = $cd
tok_LEN = $ce
tok_PEEK    = $cf
tok_RND = $d0
tok_SGN = $d1
tok_SPC = $d2
tok_TAB = $d3
tok_MID_STR    = $d4
tok_STICK   = $d5
tok_STRIG   = $d6
tok_XPOS    = $d7
tok_YPOS    = $d8
tok_VAL = $d9
tok_POS = $da
tok_CSRLIN  = $db
tok_CHR_STR    = $dc
tok_HEX_STR    = $dd
tok_INKEY_STR  = $de
tok_RIGHT_STR  = $df
tok_LEFT_STR   = $e0
tok_SCR_STR    = $e1
tok_INSTR   = $e2
tok_CRASH   = $e3
tok_ERR = $e4
tok_ERL = $e5
tok_VCT = $e6
