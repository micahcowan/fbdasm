# STACK: This document is a "note to self" that I use
# to keep track of what code I'm currently analyzing, and how I got
# there, so I can work my way back up to find the next bit of code
# to work on for some larger, overall routine.
#
# Unlike a 6502 CPU stack, all addresses given are the actual address
# (and not one less).

SEARCH STACK:
  
  I think GAME codes are stored at $D400 and on. In a data pointer table at $B00B
    Something interesting at $D000, too. a game background map, probably?
  Any other st* to NMICMD
  WaitForNmiSubcommand
  MarkWrappedLine
  PrintString
  QueueStringForOutput
  QueueCharForOutput
  QueueNullForOutput
  Any remaining fns in CtrlCharInputHandlersTbl

  ReadKeyboard

BRANCH STACK:
  DefaultNmiHandler
  A more in-depth look at what ExprUnaryOrLiteral ($A490) does
  DirectModeLoop
 $8334 ExecuteDirectModeLineIThink
 $97A6 second of two functions called when direct-mode line begins with number
 $84E5 first of two functions called when direct-mode line begins with number
  -> $904D
    -> $8EF7
  $853A
   $857F

 Write up what I know so far, and the bugs I've found

 CmdFn_LOAD

#

Saving a program to cassette:
  a clear (zero) bit is sent as a single, short (hi-freq) cycle
  a set (one) bit is sent as a single, longer (lo-freq) cycle

  everything that is sent out to cassette, is sent as:
    20,000 zeroes as padding/sync
    N set bits
    N clear bits (N varies, depending on type of data sent)
    A single set bit
    .
    The payload. Each byte consists of a single start bit, always set,
     and then an octet, MSB first.
    .
    A two-byte checksum, representing a count of how many set bits were
    in the payload. This is sent big-endian (most-significant byte first)!
    .
    A final, single set bit

  When a program is saved, two payloads are sent: program header
  (including name, size) and tokenized program text

  The program header consists of 128 bytes. The first 17 bytes are
  the program name (up to 17 chars, plus a null terminator).
  Bytes 18 and 19 contain the size of the tokenized program text,
  and bytes 20 and 21 indicate where in memory the start of the program
  was (idk if LOAD respects this). The remaining bytes are random garbage.


#

fn sub(a, b):
    if a == -32768:
        if b >= 0: # BUG. s/b: b > 0
            raise ErrorOverflow
        else:
            return add(a, -b)
    else:
        # a != -32768
        if (-a) < 0 || b < 0:
            return -( add(-a, b) )
        else:
            ret = -a + b
            if ret == -32768:
                return ret
            else if ret >= 0:
                return -ret
            else:
                raise ErrorOverflow

fn add(a, b):
    if a < 0:
        if b < 0:
            # neg plus neg
            ret = (-a) + (-b)
            if ret == -32768:
                return ret  # already negative 
            elif ret < 0:
                raise ErrorOverflow
            else:
                return -ret
        else:
            # neg plus pos
            return -( (-a) - b )
    else if b < 0:
        # pos plus neg
        return a - (-b)
    else:
        # pos plus pos
        ret = acc + parm;
        if ret < 0:
            raise ErrorOverflow
