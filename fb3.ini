# SEARCH STACK:
#   
#   I think GAME codes are stored at $D400 and on. In a data pointer table at $B00B
#     Something interesting at $D000, too. a game background map, probably?
#   Any other st* to NMICMD
#   WaitForNmiSubcommand
#   MarkWrappedLine
#   PrintString
#   QueueStringForOutput
#   QueueCharForOutput
#   QueueNullForOutput
#   Any remaining fns in CtrlCharInputHandlersTbl
#
#   ReadKeyboard

# BRANCH STACK:
#   DefaultNmiHandler
#   A more in-depth look at what ExprUnaryOrLiteral ($A490) does
#   DirectModeLoop
#  $8334 ExecuteDirectModeLineIThink
#  $97A6 second of two functions called when direct-mode line begins with number
#  $84E5 first of two functions called when direct-mode line begins with number
#   -> $904D
#     -> $8EF7
#   $853A
#    $857F

# Pointer to the start of the BASIC program code.
# Set to $6006 at the start, and AFAICT always
# has that value (never saw any code modify it to anything else)
#   Conceivably could be set by user within the program itself?
RAM $05 TxtTabL
RAM $06 TxtTabH
# The following point at the next char of BASIC program
# to be processed.
RAM $09 zpTxtPtrL
RAM $0A zpTxtPtrH
# Designates the type of data in zpAccum16.
#   #$02 = 16-bit Integer
#   #$03 = ???
RAM $27 zpAccType
# $28.29 form both the first operand, and the result,
# of various 16-bit integer operations.
RAM $28 zpAccum16L
RAM $29 zpAccum16H
# $2C.2D form the second operand of binary operators
RAM $2C zpOperand16L
RAM $2D zpOperand16H
#
RAM $32 zpPpuCtrlVal
RAM $33 zpPpuMaskVal
# The following eight bytes are used mostly
# just as arithmetic scratch space for
# multiplying numbers when calculating the
# current row's base address in VRAM.
# Used for calculating the VRAM row base addr.
#
# Or rather, only the first four bytes
# are actually used, though all of them
# are cleared beforehand. The others
# appear to be used ...never!
RAM $34 zpMulScratch34
RAM $35 zpMulScratch35
RAM $36 zpMulScratch36
RAM $37 zpMulScratch37
RAM $38 zpMulScratch38
RAM $39 zpMulScratch39
RAM $3A zpMulScratch3A
RAM $3B zpMulScratch3B
# Five bytes for holding output of HexStrFromWord.
# Entirely possible they're used for other temp storage, too.
RAM $3D zpHexStrTmp
RAM $3E zpHexStrTmp1
RAM $3F zpHexStrTmp2
RAM $40 zpHexStrTmp3
RAM $41 zpHexStrTmpTerm
RAM $44 zpLineNumL
RAM $45 zpLineNumH
# zCV was copied to this just prior to setting zpNMICMD=2 and awaiting NMI. Not sure what for.
# Other spots write other values to it.
RAM $47 zpSomeRowIndicator
# Current cursor column number
RAM $48 zpCH
# Current cursor row number
RAM $49 zpCV
# PPU address of tile under cursor
RAM $4A zpCursTileAddrL
RAM $4B zpCursTileAddrH
RAM $4D zpTokenizeOutL
RAM $4E zpTokenizeOutH
# $4F selects between zpVScroll0 and zpvScroll1
# for RECEIVING updates ($F0 seems to select between them
# for SETTING the actual PPU scroll)
RAM $4F zpPpuScreenBasePage
RAM $52 zpOutputStrL
RAM $53 zpOutputStrH
# $5B.5C point to the start of the current program line
# (that is, the 8-bit line length followed by the 16-bit line number)
RAM $5B zpTxtLinkL
RAM $5C zpTxtLinkH
RAM $62 zpOutTxtCurPos
# Tells the NMI to call a designated handler,
# whose table idx is one less than the value in $63.
# Can be looped over until zero, to wait for NMI
# to finish handling it.
RAM $63 zpNMICMD
RAM $64 zpOutTxtStartPos
RAM $6B zpSavedCH
RAM $6C zpSavedCV
RAM $6F zp6F
RAM $70 zp70
RAM $71 zp71
# $76: Index into $500 where next char should be written to
RAM $76 zpLineBufIdx
RAM $AB zp_nmi_some_flag
# if $AC is non-zero, $AB is set to #$FF (triggering flag check on next frame)
RAM $AC zp_nmi_some_flag_1
# $E4, $E5: alternative scroll positions, selected by $F0.
# NMI handler will use whichever is selected to set the scroll position just before exit.
RAM $E4 zpVScroll0
RAM $E5 zpVScroll1
RAM $ED zpNmiTrampoline
RAM $EE zpNmiTrampoline_1
RAM $EF zpNmiTrampoline_2
# If the following is set, NMI uses $E5 to set vertical scroll position;
# if reset, it uses $E4 instead
RAM $F0 zpSomeKindaScrollingFlagF0

RAM $300 TokenizeBuffer
# Current definitions of the FN-key shortcuts,
# each 16 chars
RAM $480 fnKey1_DfnBuf
RAM $490 fnKey2_DfnBuf
RAM $4A0 fnKey3_DfnBuf
RAM $4B0 fnKey4_DfnBuf
RAM $4C0 fnKey5_DfnBuf
RAM $4D0 fnKey6_DfnBuf
RAM $4E0 fnKey7_DfnBuf
RAM $4F0 fnKey8_DfnBuf

# NMICMD_PutCurrentLineIntoLineBuffer copies the full current,
# potentially multi-row line into here
RAM $500 LineBuffer

# $601 and $61B each point at the start of 24 bytes of data,
# one per visible screen row. They track whether a given
# line is wrapped or not (probably other things too?).
#
# Which one applies, is determined by
# the value of zpSomeKindaScrollingFlag ($4C): isRowWrappedArray0 ($601)
# if  $4C is exactly #$20; otherwise isRowWrappedArray1 ($61B).
RAM $601 isRowWrappedArray0
RAM $602 isRowWrappedArray0PlusOne
RAM $61B isRowWrappedArray1
RAM $61C isRowWrappedArray1PlusOne
RAM $634 KbdData
RAM $63B unkKbdFlag
# user directive messages (at least) get writen out to here:
RAM $700 outTxtBuf

# Hardware Ports

RAM $2000 PPUCTRL
RAM $2001 PPUMASK
RAM $2002 PPUSTATUS
RAM $2003 OAMADDR
RAM $2004 OAMDATA
RAM $2005 PPUSCROLL
RAM $2006 PPUADDR
RAM $2007 PPUDATA

RAM $4000 SQ1_VOL
RAM $4001 SQ1_SWEEP
RAM $4002 SQ1_LO
RAM $4003 SQ1_HI

RAM $4004 SQ2_VOL
RAM $4005 SQ2_SWEEP
RAM $4006 SQ2_LO
RAM $4007 SQ2_HI

RAM $4008 TRI_LINEAR
RAM $400A TRI_LO
RAM $400B TRI_HI

RAM $400C NOISE_VOL
RAM $400E NOISE_LO
RAM $400F NOISE_HI

RAM $4010 DMC_FREQ
RAM $4011 DMC_RAW
RAM $4012 DMC_START
RAM $4013 DMC_LEN

RAM $4014 OAM_DMA

RAM $4015 SND_CHN

RAM $4016 PAD1_KCTRL
RAM $4017 PAD2_KIN

# The start of the BASIC program in memory
RAM $6006 BasicProgram

# End Hardware Ports

CertainlyCode $0000 Start
CertainlyCode $00BA _Reset

CertainlyCode $01EC PpuGoToAX
Comment $01EC "Sets the current VRAM address from the A (high) and X (low) registers."

CertainlyCode $020D DirectTheUser
Comment $020D "Tell the user to do something"
Comment $020D "(turn backup switch on/off, power off, connect keyboard)"
CertainlyData $021C strON
CertainlyData $0220 strKEYBOARD_WO_SETSUZOKU
CertainlyData $022D strDENGEN_WO
CertainlyData $0234 strBACKUP_SWITCH_WO
CertainlyData $0242 strOFF_NI_SHITE_KUDASAI
CertainlyData $0246 strNI_SHITE_KUDASAI
CertainlyData $0248 strSHITE_KUDASAI
CertainlyCode $0284 DirectModeLoop
Comment $0284 "Loop over user input lines, obeying commands and entering"
Comment $0284 "numbered program code lines."
CertainlyCode $0334 ExecuteDirectModeLineIThink

CertainlyCode $0491 ErrorSyntax
Comment $0491 "Emit a syntax error (code [SN]) and stop execution."
Comment $0491 "In addition to being called directly from various places,"
Comment $0491 "this function is also in the jump table for the keywords"
Comment $0491 "THEN, TO, STEP, and OFF, since these are all marker tokens"
Comment $0491 "and not real commands. (ON can start legit commands,"
Comment $0491 "so it does not go here.)"
CertainlyData $0493
Comment $0493 "A neutralizing byte ($AE: ldx ABSOLUTE). If this routine is entered via $8491,"
Comment $0493 "A := #$01 and we give a syntax error. But if we're entered"
Comment $0493 "via $8494, then A := #$04 and it's Illegal Function Call (IL),"
Comment $0493 "which is often given when some command parameter does not conform"
Comment $0493 "to the expected range of values."
CertainlyCode $0494 ErrorIllegalCall
Comment $051E "Record tokenized length in zpAccum16"
Comment $0521 "subtracting #$00 is a pretty silly thing to do..."
Comment $052B ""
CertainlyCode $0540 FindLineNum
Comment $0540 "Find the position for the line number zpLineNum"
Comment $0540 "within the BASIC program, leaving zpTxttLink pointing"
Comment $0540 "at the closest less-than-or-equal numbered line."
Comment $0540 "Z flag is set iff an exact line-number match"
Comment $0540 "was found."
Comment $0540 ""
Comment $0540 "Point zpTxtLink at the program start"
Comment $054A "Read the offset to next line. Is it non-zero?"
Comment $054C "Not zero -> continue to process"
Comment $054E "Zero: no more program lines. Report and exit."
Comment $054E "Load an arbitrary non-zero arg, so beq/bne tests"
Comment $054E "show we didn't find an exact line match."
Comment $0551 "Compare high byte of the current line number, with the one "
Comment $0551 "we're looking for"
Comment $0557 "high bytes different -> Check if higher or lower"
Comment $0559 "high bytes same, check low bytes"
Comment $055E "line numbers equal? -> Return."
Comment $0560 "line number we're seeking less than line number we're at? -> Also return."
Comment $0562 "fast-forward to next BASIC line"
Comment $0571 "Loop back around and check the numbers again"

Comment $085D "Reset NMI sub-command"
CertainlyCode $093C QueueStringForOutput
Comment $093C "Copies the null-terminated string pointed at by zpOutputStr ($52) to outTxtBuf"
CertainlyCode $094B QueueNullForOutput
CertainlyCode $094D QueueCharForOutput
Comment $0957 "zpOutTxtCurPos <- #FF"
CertainlyCode $095A PrintString
Comment $095A "Copy a string to the output buffer, set zpNMICMD to NMICMD_FlushQueuedOutput,"
Comment $095A "and wait for NMI handler to finish copying to the screen."
CertainlyCode $095D PrintOutBuf
Comment $095D "NUL-terminate the output buffer, and wait for NMI to print it."
Comment $0964 "NMICMD selector for NMICMD_FlushQueuedOutput"
CertainlyCode $096A WaitForNmiSubcommand
Comment $096A "Set NMICMD and wait for NMI handler to finish processing it."
Comment $096C "wait for NMI to handle sub-command"
CertainlyCode $0971 DefaultNmiHandler
Comment $0988 "active NMI sub-command request?"
Comment $098A "yes: go handle sub-command"
Comment $0991 "Set up sub-command address, and jump"
CertainlyCode $09FA NMICMD_ClearToEndOfRow
Comment $09FA "Erases from cursor to end of current row."
CertainlyCode $0A0C NMICMD_FlushQueuedOutput
Comment $0A14 "Grab a char from out buf."
Comment $0A17 "If NUL, we've reached buffer end"
Comment $0A19 "Copy the character to the screen"
Comment $0A1C "Advance the cursor"
Comment $0A20 "Have we reached the end of the screen line?"
Comment $0A22 "yes -> handle wraparound to next line"
Comment $0A26 "Are we at the 15th column?"
Comment $0A28 "yes -> done printing for this frame"
Comment $0A2B "Loop back to output next character (always branch)"
Comment $0A2E "Done printing for this frame."
Comment $0A2E "Save our progress, and continue next frame."
Comment $0A33 "We reached the end of the screen line: wrap around to next column"
Comment $0A50 "Output cursor has gone to a line below the screen."
Comment $0A50 "I'm guessing following code scrolls the screen?"
Comment $0A7F "Indicate end of screen outputting, reset output buffer, cleanup, and exit."
Comment $0A7F "(This will terminate any loop awaiting this command's completion.)"
CertainlyCode $0A87 NMICMD_PutCurrentLineIntoLineBuffer
Comment $0A87 "Copies the current row, through to the end of the line,"
Comment $0A87 "into LineBuffer."
Comment $0A87 "(copies multiple rows if the line is wrapped)."
Comment $0A87 "This command is invoked when handling CR on input,"
Comment $0A87 "to get a copy of the line for input processing."
Comment $0AAD "line doesn't wrap -> terminate active NMICMD."
Comment $0AAF "line wraps: copy that on next NMI hit."

CertainlyCode $0ABA NmiTerminateSubCmdCleanupAndExit
CertainlyCode $0ABC NmiTransitionSubCmdCleanupAndExit
CertainlyCode $0ABE NmiCleanupAndExit
Comment $0ABE "Some kind of NMI cleanup must happen here -"
Comment $0ABE "Lots of NMICMD handlers jump to here when done."

CertainlyCode $0BA4 InitLineBufferScanning
Comment $0BA4 "Point zpTxtPtr at LineBuffer ($500)"

CertainlyCode $0E32 WordNegate
CertainlyCode $0EF2 ErrorOverflow
CertainlyCode $0EF7 WordAdd
Comment $0EF7 "Adds $2C.2D to $28.29, leaves in $28.29."
CertainlyCode $0F05 ClearMultiplyScratchSpace
Comment $0F05 "Clears the scratch space used by WordMultiply."
Comment $0F05 "The first byte ($34) is never actually"
Comment $0F05 "cleared (not necessary), and the last four ($38 thru $3B)"
Comment $0F05 "are never actually used by anything."
CertainlyCode $0F35 WordMultiplyAsWord
Comment $0F35 "Multiply, and cause an overflow error (OV) if it doesn't fit in a word."
Comment $0F35 "BUG: won't cause overflow if (result MOD (2 ** 24)) fits in a word."
Comment $0F35 "for example, multiplying 4095 * 4095 produces overflow,"
Comment $0F35 "but multiplying 4097 * 4097 does NOT."
Comment $0F35 "This is because it checks for overflow in $36, but not in $37."
CertainlyCode $0F47 "WordMultiply"
Comment $0F47 "Multiplies the contents of $28.29 by $2C.2D"
Comment $0F47 "leaving the results in $28.29."

CertainlyCode $10A6 DecrementTxtPtr
CertainlyCode $10B2 GetTxtChar
Comment $10B2 "Get the next program character (doesn't increment)"
CertainlyCode $10B7 SetTxtCharDEAD
Comment $10B7 "Likely dead code"
CertainlyCode $108C IncrementTxtPtr
CertainlyCode $1098 IncrementAndGetTxtChar
CertainlyCode $10BF TxtSkipSpaces
CertainlyCode $10C8 TxtPtrIsNonDigit
Comment $10C8 "Sets carry if TxtPtr points at a non-numeric character."
CertainlyCode $10FD ParseDecimalWordFromTxt
CertainlyCode $10FD "Parses a decimal number at zpTxtPtr into zpAccum16,"
CertainlyCode $10FD "leaving TxtPtr after the number."

CertainlyCode $11B8 HexFromNybble
Comment $11B8 "Converts a value from $0-$F to a hex digit in ASCII."
CertainlyCode $11C3 HexCharsFromByte
Comment $11C3 "Converts a byte into two hex digits in ASCII,"
Comment $11C3 "storing them at $3D + x."
CertainlyCode $11DA HexStrFromWord
Comment $11DA "Converts a word (at $28) into a null-terminated string of"
Comment $11DA "four hexadecimal digits in ASCII, stored at $3D thru $41."
CertainlyCode $125B TokenizeIThink
CertainlyCode $1677 ErrorReturnWithoutGosub

CertainlyCode $2283 FrmEval
Comment $2283 "Evaluate the formula at the current location in"
Comment $2283 "the BASIC program tokenized text."
CertainlyCode $229B Expression
Comment $229B "The formula evaluator does a recursive parser thing,"
Comment $229B "instead of operator precedence. Most of these parsers"
Comment $229B "are in page $A2. One first calls Expression (this fn),"
Comment $229B "which calls ExprOR, which calls ExprAND, etc,"
Comment $229B "until it gets about 9 calls deep and finally hits"
Comment $229B "ExprUnaryOrLiteral, which processes unary ops, vars, and"
Comment $229B "literals, and then if it finds a binary op it sets"
Comment $229B "the accumulator to that op's token code, and "
Comment $229B "falls back up the chain, letting one of the recursive"
Comment $229B "handlers deal with it. This technique is easier to code,"
Comment $229B "but not terribly efficient."
Comment $229B ""
Comment $229B "Expression itself (this fn) directly handles"
Comment $229B "XOR expressions (the lowest-precedence binary op),"
Comment $229B "delegating to ExprOr (and below) for any"
Comment $229B "higher-precedence op than XOR."
CertainlyCode $22BE ExprOr
Comment $22BE "Parse an OR expression,"
Comment $22BE "or an expression of higher precedence."
CertainlyCode $22E1 ExprAnd
Comment $22E1 "Parse an AND expression,"
Comment $22E1 "or an expression of higher precedence."
CertainlyCode $2304 ExprRelOp
Comment $2304 "Parse a relational expression (<>, >=, <=, =, >, <)"
Comment $2304 "or an expression of higher precedence."
CertainlyCode $2341 ExprPlusMinus
Comment $2341 "Parse an addition or subtraction expression,"
Comment $2341 "or an expression of higher precedence."
Comment $234D "addition"
Comment $2356 "subtraction"
CertainlyCode $2373 ExprMod
Comment $2373 "Parse a modulo expression,"
Comment $2373 "or an expression of higher precedence."
CertainlyCode $2392 ExprMulDiv
Comment $2392 "Parse a multiplication or division expression,"
Comment $2392 "or an expression of higher precedence."
Comment $239E "division"
Comment $23A7 "multiplication"
CertainlyCode $2490 ExprUnaryOrLiteral
Comment $2490 "Handles unary operators, and literals (-, NOT, Ctrl-R, Ctrl-Q,"
Comment $2490 "+, parentheses, double-quote, var names, other punctuation, ..."
CertainlyCode $29FF ErrorTypeMismatch
CertainlyCode $2A0D ErrorUnlessInteger
CertainlyData $2A0F
Comment $2A0F "Disarming byte ($AE = ldx ABSOLUTE)"
CertainlyCode $2A10 ErrorUnlessXXXSomething

CertainlyCode $3237 PrintErrorAndStop
Comment $3237 "Prints the two-character error code"
Comment $3237 "and (presumably) returns to direct mode."
Comment $3283 "Print '?' char"
CertainlyCode $32F7 PrintStartupText
CertainlyCode $3327 PrintHotStart

CertainlyData $3338 strBASIC_HOT_START
CertainlyData $3349 strBYTES_FREE
CertainlyData $3349 strBYTES_FREE
CertainlyData $3355 strIN
CertainlyData $335A strBREAK
CertainlyData $3360 strERROR
CertainlyData $3367 strWRITING
CertainlyData $3370 strLOADING
CertainlyData $3379 strSKIP
Comment $337F "READ THESE AS LOW-THEN-HI (order of chars is reverse of what appears in words below)" 
Comment $337F "[NF]: NEXT without FOR"
Comment $3381 "[SN]: Syntax Error"
Comment $3383 "[RG]: RETURN without GOSUB"
Comment $3385 "[OD]: Out of Data"
Comment $3387 "[IL]: Illegal function call"
Comment $3389 "[OV]: Overflow"
Comment $338B "[OM]: Out of Memory"
Comment $338D "[UL]: Undefined Line number"
Comment $338F "[SO]: Subscript Out of range"
Comment $3391 "[DD]: Duplicate Definition"
Comment $3393 "[DZ]: Division by Zero"
Comment $3395 "[TM]: Type Mismatch"
Comment $3397 "[ST]: String Too long"
Comment $3399 "[FT]: Formula Too complex"
Comment $339B "[CC]: Cannot Continue"
Comment $339D "[UF]: Undefined Function"
Comment $339F "[MO]: Missing Operand"
Comment $33A1 "[TP]: Tape read error"
Comment $33A3 "[NR]: No Resume"
Comment $33A5 "[RE]: RESUME without ERROR"
Comment $33A7 "[NB]: No BG Data"
Comment $33A9 "[UP]: Unprintable Error"

CertainlyCode $342B WaitForVBlank
CertainlyData $344A strGAME_0
Comment $344A "This and the following strings are used to set"
Comment $344A "the default FN key shorthands."
CertainlyData $3452 strGAME_1
CertainlyData $345A strGAME_2_1
CertainlyData $3464 strGAME_3
CertainlyData $346C strSPRITE
CertainlyData $3474 strLOAD
CertainlyData $347A strLIST
CertainlyData $3480 strRUN

CertainlyCode $34F4 CalcCursorTilemapPos
Comment $34F4 "Calculates the PPU address corresponding to the current cursor position."
Comment $3518 "At this point, $2C,$2D = (zpVScroll/8) + CV + 3) MOD 30"
Comment $3518 "or rather, the current row number relative to the actual"
Comment $3518 "start of the tilemap in VRAM (not just 'top of screen,"
Comment $3518 "like zpCV)."
Comment $3518 "We set the multiplier to 32, or the size of a row on the screen"
Comment $3518 "(including margins)"

CertainlyCode $352E PpuGoToCursor
Comment $352E "Sets the current VRAM address to the cursor's current tile position"

CertainlyCode $3539 NmiWriteTileSetVScrollAndEnableNMI
CertainlyCode $353C NmiSetVScrollAndEnableNMI
Comment $353C "Set the vertical scroll position from either zpVScroll0 or zpVScroll1,"
Comment $353C "depending on the value of zpSomeKindaScrollingFlag"
CertainlyCode $3559 AwaitVBlankAndZeroPpuMask
CertainlyCode $3562 AwaitVBlankAndUpdatePpuMask
CertainlyCode $35AD CursorToNextRowStart
Comment $35AD "Advance the cursor to the start of the next row."
Comment $35AD "Does exactly the same thing as CursorDown."
CertainlyCode $35B5 ControlCharNOOP
Comment $35B5 "Control-key handler for control chars that don't do anything when input."
CertainlyCode $35B8 CursorToNextLineStart
Comment $35B8 "Advance the cursor to the start of the next line,"
Comment $35B8 "skipping over any wrapped rows in the current one."
CertainlyCode $35C7 ScrollScreenUpOneRow
Comment $35C7 "Scrolls the screen up by one row, leaving the cursor"
Comment $35C7 "on the first row of the (new) last row)."
Comment $35C7 ""
Comment $35C7 "Erases the top line just before scrolling it up (so it can become"
Comment $35C7 "a future new line when we scroll down to it in future)."
Comment $35CF "Tell NMI handler to erase to end of row"
Comment $35CF "(Cursor is at home row, so erase entire top row)"
CertainlyCode $35D4 ScrollScreenOneRowNoErase
Comment $35D4 "Scrolls the screen WITHOUT clearing any lines."
Comment $35D4 "Unlike many other systems, Family Basic doesn't scroll"
Comment $35D4 "by copying lines upward: the tilemap is vertically"
Comment $35D4 "'mirrored' (repeated), so we have only to adjust"
Comment $35D4 "the PPU vertical scroll register. Very fast scrolls!"
Comment $35D4 ""
Comment $35D4 "Fun thing to try:"
Comment $35D4 ""
Comment $35D4 "  10 CALL -18988:FOR P=1 TO 100:NEXT:GOTO 10"
Comment $35D4 ""
Comment $35D4 "(-18988 is this routine.)"
Comment $35D4 "Then, optionally fill the screen with interesting things"
Comment $35D4 "and then RUN. It'll scroll the screen in a cycle!"

Comment $361A "always branches."
CertainlyCode $3637 DoesRowWrap
Comment $3637 "Returns whether the row identified in register x"
Comment $3637 "wraps to the next row"
CertainlyCode $3645 MarkWrappedLine
Comment $3645 "Record that a given line was wrapped,"
Comment $3645 "and does not begin a new line of its own."
CertainlyCode $3656 SaveCursorPos
CertainlyCode $365F RestoreCursorPos
CertainlyCode $36DF HandleTabKey
CertainlyCode $368F ClearToEndOfLine
Comment $368F "Clears to end of current (possibly multi-row) line"
CertainlyCode $3710 CursorUp
CertainlyCode $3717 CursorDownPreserveCol
Comment $3717 "Exactly the same as CursorDown, _except_ in the case when"
Comment $3717 "the cursor moves past the end of the screen. In that case,"
Comment $3717 "CursorDown will leave cursor at the start of the new line;"
Comment $3717 "CursorDownPreserveCol will leave cursor at the original column."
CertainlyCode $3721 CursorLeft
Comment $3721 "already at leftmost column?"
Comment $3723 "yes -> check if we can go up a row"
Comment $3725 "no, so just back up a column."
Comment $3728 "already at topmost row?"
Comment $372A "yes -> nothing to do, exit"
Comment $372C "no, so go up a row and to the rightmost column"
CertainlyCode $3733 CursorRight
Comment $3735 "already in rightmost column?"
Comment $3737 "yes -> check if we can go to next row"
Comment $3739 "no, just go right a column"
Comment $3741 "are we on the last row?"
Comment $3743 "yes -> nothing to do, exit"
Comment $3745 "no, just drop down a row"
CertainlyCode $3748 CursorHome
CertainlyCode $374C CursorToRowStart
CertainlyCode $3751 CursorDown
Comment $3753 "increment row"
Comment $3754 "past last row?"
Comment $3756 "no -> store new row and exit"
Comment $3758 "yes"
CertainlyCode $376F Backspace

CertainlyCode $3958 ReadKeyboard
Comment $3958 "Kbd reading routine."
Comment $3958 "See https://www.nesdev.org/wiki/Family_BASIC_Keyboard#Hardware_interface for details."
Comment $3958 ""
Comment $3958 "Write $05 to keyboard: reset row/col scanning"
Comment $3965 "Write $04: prep read for column 0 of a new row"
#
Comment $3971 ""
Comment $3971 "                    bit: 7       0"
Comment $3971 "Read col 0 scan results: ---x xxx-"
Comment $3971 ""
Comment $3971 "row 0: ]   ]   RET F8"
Comment $3971 "    1: ;   :   @   F7"
Comment $3971 "    2: K   L   O   F6"
Comment $3971 "    3: J   U   I   F5"
Comment $3971 "    4: H   G   Y   F4"
Comment $3971 "    5: D   R   T   F3"
Comment $3971 "    6: A   S   W   F2"
Comment $3971 "    7: CTR Q   ESC F1"
Comment $3971 "    8: LFT RGT UP  CLR"
Comment $3971 ""
#
Comment $3974 "Move to occupy the low nybble"
Comment $3977 "...and store in KbdData + <<ROW>>"
#
Comment $397A "Write $06: prep read for column 1, same row"
#
Comment $3986 ""
Comment $3986 "                    bit: 7       0"
Comment $3986 "Read col 1 scan results: ---x xxx-"
Comment $3986 ""
Comment $3986 "row 0: STP \   RSH KANA"
Comment $3986 "    1: ^   -   /   _"
Comment $3986 "    2: 0   P   ,   ."
Comment $3986 "    3: 8   9   N   M"
Comment $3986 "    4: 6   7   V   B"
Comment $3986 "    5: 4   5   C   F"
Comment $3986 "    6: 3   E   Z   X"
Comment $3986 "    7: 2   1   GRP LSH"
Comment $3986 "    8: INS DEL sPC DWN"
Comment $3986 ""
#
Comment $3989 "Move to occupy the high nybble"
Comment $398E "Combine with low nybble (cols 0 and 1 now combined)"
Comment $3991 "Invert the bits, so that 1 = pressed"
Comment $3993 "And then store them in reversed order"
Comment $399F "Loop around to handle the next keyboard row"
CertainlyCode $3C20 ReadChar
CertainlyData $3CD4
Comment $3CD4 "Disarming byte (2C = bit ABSOLUTE) for the following instruction"
CertainlyCode $3CD5 KeyClick

CertainlyCode $3D04 ReadLine
Comment $3D04 "Read a line of user input into LineBuffer"
Comment $3D2F "Handle CR character from input (come-from $BD0D)
Comment $3D2F "First: back up rows until we're not on a wrapped one"
Comment $3D2F "(that is, we're at the first row of a possible"
Comment $3D2F "multi-row line)"
Comment $3D31 "Exit loop if we're on the topmost line"
Comment $3D3C "Row is wrapped: loop back to preceding row"
Comment $3D45 "Fetch the on-screen, possibly-wrapped line from PPU"
Comment $3D45 "into LineBuffer"
Comment $3D58 "Loop: strip any trailing spaces from line"
Comment $3D61 "Space: strip it and loop on preceding character"

CertainlyCode $3E0E SetPpuCtrl
Comment $3E0E "NOTE: Vblank NMI will be DISABLED, unless the high bit is set in zpPpuCtrlVal"
CertainlyCode $3E14 SetPpuCtrlAndEnableNMI

CertainlyData $4F7B strNS_HUDSON
Comment $4F7B "'NS-HUBASIC V3.0'"
CertainlyData $4F8C strCOPYRIGHT_MSG
Comment $4F8C "'Â© NINTENDO/SHARP/HUDSON'"

########################################

# START COMMAND FUNCS
CertainlyCode $16C6 CmdFn_GOTO
CertainlyCode $1648 CmdFn_GOSUB
CertainlyCode $06B0 CmdFn_RUN
CertainlyCode $16A6 CmdFn_RETURN
CertainlyCode $1EC9 CmdFn_RESTORE
#CertainlyCode $0491 CmdFn_THEN
CertainlyCode $0767 CmdFn_LIST
CertainlyCode $018F CmdFn_SYSTEM
#CertainlyCode $0491 CmdFn_TO
#CertainlyCode $0491 CmdFn_STEP
CertainlyCode $2FFC CmdFn_SPRITE
CertainlyCode $08C5 CmdFn_PRINT
CertainlyCode $17FC CmdFn_FOR
CertainlyCode $1887 CmdFn_NEXT
CertainlyCode $1716 CmdFn_PAUSE
CertainlyCode $193C CmdFn_INPUT
CertainlyCode $1A6C CmdFn_LINPUT
CertainlyCode $0467 CmdFn_DATA
CertainlyCode $1782 CmdFn_IF
CertainlyCode $1F36 CmdFn_READ
CertainlyCode $1C0C CmdFn_DIM
CertainlyCode $0467 CmdFn_REM
CertainlyCode $085B CmdFn_STOP
CertainlyCode $089C CmdFn_CONT
CertainlyCode $2E0A CmdFn_CLS
CertainlyCode $17A4 CmdFn_CLEAR
CertainlyCode $1AFD CmdFn_ON
#CertainlyCode $0491 CmdFn_OFF
CertainlyCode $4BDC CmdFn_CUT
CertainlyCode $04B6 CmdFn_NEW
CertainlyCode $175D CmdFn_POKE
CertainlyCode $2F4F CmdFn_CGSET
CertainlyCode $3153 CmdFn_VIEW
CertainlyCode $4BB3 CmdFn_MOVE
CertainlyCode $026A CmdFn_END
CertainlyCode $201E CmdFn_PLAY
CertainlyCode $3CD0 CmdFn_BEEP
CertainlyCode $1DE1 CmdFn_LOAD
CertainlyCode $1D64 CmdFn_SAVE
CertainlyCode $4B9B CmdFn_POSITION
CertainlyCode $1B68 CmdFn_KEY
CertainlyCode $44CA CmdFn_COLOR
CertainlyCode $3098 CmdFn_DEF
CertainlyCode $2ED1 CmdFn_CGEN
CertainlyCode $1A0E CmdFn_SWAP
CertainlyCode $170A CmdFn_CALL
CertainlyCode $1748 CmdFn_LOCATE
CertainlyCode $2EF3 CmdFn_PALET
CertainlyCode $4BD9 CmdFn_ERA
CertainlyCode $162B CmdFn_TR
CertainlyCode $1573 CmdFn_FIND
CertainlyCode $2D5B CmdFn_GAME
CertainlyCode $3FD1 CmdFn_BGTOOL
CertainlyCode $0BDA CmdFn_AUTO
CertainlyCode $0758 CmdFn_DELETE
CertainlyCode $0C30 CmdFn_RENUM
CertainlyCode $2EB8 CmdFn_FILTER
CertainlyCode $1625 CmdFn_CLICK
CertainlyCode $2E48 CmdFn_SCREEN
CertainlyCode $018F CmdFn_BACKUP
CertainlyCode $1510 CmdFn_ERROR
CertainlyCode $1527 CmdFn_RESUME
CertainlyCode $3201 CmdFn_BGPUT
CertainlyCode $31B8 CmdFn_BGGET
CertainlyCode $4C6C CmdFn_CAN
# END COMMAND FUNCS

# START TOKENS
CertainlyData $4CAB KeywordTokensTable
Comment $4CAB "'GOTO'"
CertainlyData $4CB0 tok_GOSUB
Comment $4CB0 "'GOSUB'"
CertainlyData $4CB6 tok_RUN
Comment $4CB6 "'RUN'"
CertainlyData $4CBA tok_RETURN
Comment $4CBA "'RETURN'"
CertainlyData $4CC1 tok_RESTORE
Comment $4CC1 "'RESTORE'"
CertainlyData $4CC9 tok_THEN
Comment $4CC9 "'THEN'"
CertainlyData $4CCE tok_LIST
Comment $4CCE "'LIST'"
CertainlyData $4CD3 tok_SYSTEM
Comment $4CD3 "'SYSTEM'"
CertainlyData $4CDA tok_TO
Comment $4CDA "'TO'"
CertainlyData $4CDD tok_STEP
Comment $4CDD "'STEP'"
CertainlyData $4CE2 tok_SPRITE
Comment $4CE2 "'SPRITE'"
CertainlyData $4CE9 tok_PRINT
Comment $4CE9 "'PRINT'"
CertainlyData $4CEF tok_FOR
Comment $4CEF "'FOR'"
CertainlyData $4CF3 tok_NEXT
Comment $4CF3 "'NEXT'"
CertainlyData $4CF8 tok_PAUSE
Comment $4CF8 "'PAUSE'"
CertainlyData $4CFE tok_INPUT
Comment $4CFE "'INPUT'"
CertainlyData $4D04 tok_LINPUT
Comment $4D04 "'LINPUT'"
CertainlyData $4D0B tok_DATA
Comment $4D0B "'DATA'"
CertainlyData $4D10 tok_IF
Comment $4D10 "'IF'"
CertainlyData $4D13 tok_READ
Comment $4D13 "'READ'"
CertainlyData $4D18 tok_DIM
Comment $4D18 "'DIM'"
CertainlyData $4D1C tok_REM
Comment $4D1C "'REM'"
CertainlyData $4D20 tok_STOP
Comment $4D20 "'STOP'"
CertainlyData $4D25 tok_CONT
Comment $4D25 "'CONT'"
CertainlyData $4D2A tok_CLS
Comment $4D2A "'CLS'"
CertainlyData $4D2E tok_CLEAR
Comment $4D2E "'CLEAR'"
CertainlyData $4D34 tok_ON
Comment $4D34 "'ON'"
CertainlyData $4D37 tok_OFF
Comment $4D37 "'OFF'"
CertainlyData $4D3B tok_CUT
Comment $4D3B "'CUT'"
CertainlyData $4D3F tok_NEW
Comment $4D3F "'NEW'"
CertainlyData $4D43 tok_POKE
Comment $4D43 "'POKE'"
CertainlyData $4D48 tok_CGSET
Comment $4D48 "'CGSET'"
CertainlyData $4D4E tok_VIEW
Comment $4D4E "'VIEW'"
CertainlyData $4D53 tok_MOVE
Comment $4D53 "'MOVE'"
CertainlyData $4D58 tok_END
Comment $4D58 "'END'"
CertainlyData $4D5C tok_PLAY
Comment $4D5C "'PLAY'"
CertainlyData $4D61 tok_BEEP
Comment $4D61 "'BEEP'"
CertainlyData $4D66 tok_LOAD
Comment $4D66 "'LOAD'"
CertainlyData $4D6B tok_SAVE
Comment $4D6B "'SAVE'"
CertainlyData $4D70 tok_POSITION
Comment $4D70 "'POSITION'"
CertainlyData $4D79 tok_KEY
Comment $4D79 "'KEY'"
CertainlyData $4D7D tok_COLOR
Comment $4D7D "'COLOR'"
CertainlyData $4D83 tok_DEF
Comment $4D83 "'DEF'"
CertainlyData $4D87 tok_CGEN
Comment $4D87 "'CGEN'"
CertainlyData $4D8C tok_SWAP
Comment $4D8C "'SWAP'"
CertainlyData $4D91 tok_CALL
Comment $4D91 "'CALL'"
CertainlyData $4D96 tok_LOCATE
Comment $4D96 "'LOCATE'"
CertainlyData $4D9D tok_PALET
Comment $4D9D "'PALET'"
CertainlyData $4DA3 tok_ERA
Comment $4DA3 "'ERA'"
CertainlyData $4DA7 tok_TR
Comment $4DA7 "'TR'"
CertainlyData $4DAA tok_FIND
Comment $4DAA "'FIND'"
CertainlyData $4DAF tok_GAME
Comment $4DAF "'GAME'"
CertainlyData $4DB4 tok_BGTOOL
Comment $4DB4 "'BGTOOL'"
CertainlyData $4DBB tok_AUTO
Comment $4DBB "'AUTO'"
CertainlyData $4DC0 tok_DELETE
Comment $4DC0 "'DELETE'"
CertainlyData $4DC7 tok_RENUM
Comment $4DC7 "'RENUM'"
CertainlyData $4DCD tok_FILTER
Comment $4DCD "'FILTER'"
CertainlyData $4DD4 tok_CLICK
Comment $4DD4 "'CLICK'"
CertainlyData $4DDA tok_SCREEN
Comment $4DDA "'SCREEN'"
CertainlyData $4DE1 tok_BACKUP
Comment $4DE1 "'BACKUP'"
CertainlyData $4DE8 tok_ERROR
Comment $4DE8 "'ERROR'"
CertainlyData $4DEE tok_RESUME
Comment $4DEE "'RESUME'"
CertainlyData $4DF5 tok_BGPUT
Comment $4DF5 "'BGPUT'"
CertainlyData $4DFB tok_BGGET
Comment $4DFB "'BGGET'"
CertainlyData $4E01 tok_CAN
Comment $4E01 "'CAN'"
CertainlyData $4E05 tok_XOR
Comment $4E05 "'XOR'"
CertainlyData $4E09 tok_OR
Comment $4E09 "'OR'"
CertainlyData $4E0C tok_AND
Comment $4E0C "'AND'"
CertainlyData $4E10 tok_NOT
Comment $4E10 "'NOT'"
CertainlyData $4E14 tok_OP_NE
Comment $4E14 "'<>'"
CertainlyData $4E17 tok_OP_GE
Comment $4E17 "'>='"
CertainlyData $4E1A tok_OP_LE
Comment $4E1A "'<='"
CertainlyData $4E1D tok_OP_EQ
Comment $4E1D "'='"
CertainlyData $4E1F tok_OP_GT
Comment $4E1F "'>'"
CertainlyData $4E21 tok_OP_LT
Comment $4E21 "'<'"
CertainlyData $4E23 tok_OP_PLUS
Comment $4E23 "'+'"
CertainlyData $4E25 tok_OP_MINUS
Comment $4E25 "'-'"
CertainlyData $4E27 tok_MOD
Comment $4E27 "'MOD'"
CertainlyData $4E2B tok_OP_DIV
Comment $4E2B "'/'"
CertainlyData $4E2D tok_OP_MUL
Comment $4E2D "'*'"
CertainlyData $4E2F tok_ABS
Comment $4E2F "'ABS'"
CertainlyData $4E33 tok_ASC
Comment $4E33 "'ASC'"
CertainlyData $4E37 tok_STR_STR
Comment $4E37 "'STR$'"
CertainlyData $4E3C tok_FRE
Comment $4E3C "'FRE'"
CertainlyData $4E40 tok_LEN
Comment $4E40 "'LEN'"
CertainlyData $4E44 tok_PEEK
Comment $4E44 "'PEEK'"
CertainlyData $4E49 tok_RND
Comment $4E49 "'RND'"
CertainlyData $4E4D tok_SGN
Comment $4E4D "'SGN'"
CertainlyData $4E51 tok_SPC
Comment $4E51 "'SPC'"
CertainlyData $4E55 tok_TAB
Comment $4E55 "'TAB'"
CertainlyData $4E59 tok_MID_STR
Comment $4E59 "'MID$'"
CertainlyData $4E5E tok_STICK
Comment $4E5E "'STICK'"
CertainlyData $4E64 tok_STRIG
Comment $4E64 "'STRIG'"
CertainlyData $4E6A tok_XPOS
Comment $4E6A "'XPOS'"
CertainlyData $4E6F tok_YPOS
Comment $4E6F "'YPOS'"
CertainlyData $4E74 tok_VAL
Comment $4E74 "'VAL'"
CertainlyData $4E78 tok_POS
Comment $4E78 "'POS'"
CertainlyData $4E7C tok_CSRLIN
Comment $4E7C "'CSRLIN'"
CertainlyData $4E83 tok_CHR_STR
Comment $4E83 "'CHR$'"
CertainlyData $4E88 tok_HEX_STR
Comment $4E88 "'HEX$'"
CertainlyData $4E8D tok_INKEY_STR
Comment $4E8D "'INKEY$'"
CertainlyData $4E94 tok_RIGHT_STR
Comment $4E94 "'RIGHT$'"
CertainlyData $4E9B tok_LEFT_STR
Comment $4E9B "'LEFT$'"
CertainlyData $4EA1 tok_SCR_STR
Comment $4EA1 "'SCR$'"
CertainlyData $4EA6 tok_INSTR
Comment $4EA6 "'INSTR'"
CertainlyData $4EAC tok_CRASH
Comment $4EAC "'CRASH'"
CertainlyData $4EB2 tok_ERR
Comment $4EB2 "'ERR'"
CertainlyData $4EB6 tok_ERL
Comment $4EB6 "'ERL'"
CertainlyData $4EBA tok_VCT
Comment $4EBA "'VCT'"
# END TOKENS

# Jump table definitions must appear AFTER any associated function names
DataTable $0250 $0251 2 7 tbl_DirectTheUserStrs
JumpTable $09A3 $09A4 2 15 NMICMD_JumpTable
DataTable $337F $3380 2 22 twoCharErrCodes
JumpTable $38BE $38BF 2 32 CtrlCharInputHandlersTbl
JumpTable $7FFA $7FFB 2 3 Vectors
JumpTable $4EBF $4EC0 2 65 CommandsJumpTable
